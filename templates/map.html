<!DOCTYPE html>
<html>
<head>
    <title>Cat GPS - Map</title>
    <style>
        :root {
            color-scheme: light dark;

            /* Page + map surfaces */
            --page-bg: #f5f5f7;
            --map-bg: #ffffff;

            /* Rooms */
            --room-stroke: #cbd5e1;
            --room-fill-lightness: 72%;
            --room-label-color: #111827;
            --room-label-stroke: transparent;

            /* Cats */
            --cat-label-color: #111827;
            --cat-label-stroke: transparent;
            --cat-icon-stroke: #ffffff;

            /* Misc */
            --node-color: #9ca3af;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --page-bg: #020617;
                --map-bg: #0b1120;
                --room-stroke: #1f2937;
                --room-fill-lightness: 25%;

                --room-label-color: #e5e7eb;
                --room-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-label-color: #f9fafb;
                --cat-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-icon-stroke: #0b1120;
                --node-color: #9ca3af;
            }
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: var(--page-bg);
        }

        #map {
            width: 100vw;
            height: 100vh;
            background: var(--map-bg);
            cursor: grab;
        }

        #map:active {
            cursor: grabbing;
        }

        .room polygon {
            stroke: var(--room-stroke);
            stroke-width: 1;
        }

        .room__label {
            font-size: 10px;
            font-family: sans-serif;
            fill: var(--room-label-color);
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--room-label-stroke);
            stroke-width: 2px;
        }

        .cat {
            transition: transform 0.3s ease-out;
        }

        .cat__icon {
            stroke: var(--cat-icon-stroke);
            stroke-width: 2;
        }

        .cat__label {
            font-size: 12px;
            font-weight: bold;
            font-family: sans-serif;
            fill: var(--cat-label-color);
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--cat-label-stroke);
            stroke-width: 2px;
        }

        .node {
            fill: var(--node-color);
        }
    </style>
</head>
<body>
    <svg id="map" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
        <g id="viewport">
            <g id="rooms">
                {% for room in rooms %}
                <g class="room" data-room-id="{{ room.name }}">
                    <polygon points="{% for point in room.svg_points %}{{ point[0] }},{{ point[1] }}{% if not loop.last %} {% endif %}{% endfor %}" style="fill: hsl({{ loop.index0 * 25 }}, 55%, var(--room-fill-lightness));" />
                </g>
                {% endfor %}
            </g>
            <g id="room-labels">
                {% for room in rooms %}
                <text class="room__label" x="{{ room.label_x }}" y="{{ room.label_y }}">{{ room.name }}</text>
                {% endfor %}
            </g>
            <g id="nodes">
                {% for node in nodes %}
                <circle class="node" cx="{{ node.x }}" cy="{{ node.y }}" r="3" />
                {% endfor %}
            </g>
            <g id="cats"></g>
        </g>
    </svg>
    <script>
        const bounds = { minX: {{ min_x }}, minY: {{ min_y }}, maxX: {{ max_x }}, maxY: {{ max_y }} };
        const svg = document.getElementById('map');
        const viewport = document.getElementById('viewport');
        const catsLayer = document.getElementById('cats');

        const svgWidth = 800;
        const svgHeight = 600;
        const baseScaleX = svgWidth / (bounds.maxX - bounds.minX);
        const baseScaleY = svgHeight / (bounds.maxY - bounds.minY);
        const baseScale = Math.min(baseScaleX, baseScaleY);

        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX, lastY;

        function toSvg(x, y) {
            const sx = (x - bounds.minX) * baseScale;
            const sy = svgHeight - (y - bounds.minY) * baseScale;
            return [sx, sy];
        }

        function updateViewport() {
            viewport.setAttribute('transform', `translate(${panX}, ${panY}) scale(${zoom})`);
        }

        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (svgWidth / rect.width);
            const my = (e.clientY - rect.top) * (svgHeight / rect.height);

            const oldZoom = zoom;
            zoom *= e.deltaY < 0 ? 1.1 : 0.9;
            zoom = Math.max(0.5, Math.min(10, zoom));

            panX = mx - (mx - panX) * (zoom / oldZoom);
            panY = my - (my - panY) * (zoom / oldZoom);
            updateViewport();
        });

        svg.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        svg.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = svg.getBoundingClientRect();
            const scaleFactorX = svgWidth / rect.width;
            const scaleFactorY = svgHeight / rect.height;
            panX += (e.clientX - lastX) * scaleFactorX;
            panY += (e.clientY - lastY) * scaleFactorY;
            lastX = e.clientX;
            lastY = e.clientY;
            updateViewport();
        });

        svg.addEventListener('mouseup', () => { isDragging = false; });
        svg.addEventListener('mouseleave', () => { isDragging = false; });

        const cats = {};
        const catColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
        let colorIndex = 0;

        function createCatElement(id, name, color) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('cat');
            g.id = `cat-${id}`;
            g.innerHTML = `
                <circle class="cat__icon" r="8" fill="${color}" />
                <text class="cat__label" y="-14">${name}</text>
            `;
            catsLayer.appendChild(g);
            return g;
        }

        function updateCatPosition(id, x, y) {
            const cat = cats[id];
            if (!cat || !cat.element) return;
            const [sx, sy] = toSvg(x, y);
            cat.element.setAttribute('transform', `translate(${sx}, ${sy})`);
        }

        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${wsProtocol}//${location.host}/ws/positions`);
        ws.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (!cats[data.device_id]) {
                const color = catColors[colorIndex++ % catColors.length];
                const element = createCatElement(data.device_id, data.device_name, color);
                cats[data.device_id] = { element, color };
            }
            const label = cats[data.device_id].element.querySelector('.cat__label');
            if (label) label.textContent = data.device_name;
            updateCatPosition(data.device_id, data.x, data.y);
        };
    </script>
</body>
</html>
