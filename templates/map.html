<!DOCTYPE html>
<html>
<head>
    <title>Cat GPS - Map</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #1a1a2e; }
        canvas { border: 1px solid #333; }
    </style>
</head>
<body>
    <canvas id="map" width="800" height="600"></canvas>
    <script>
        const rooms = {{ rooms | tojson }};
        const bounds = { minX: {{ min_x }}, minY: {{ min_y }}, maxX: {{ max_x }}, maxY: {{ max_y }} };
        const canvas = document.getElementById('map');
        const ctx = canvas.getContext('2d');

        const baseScaleX = canvas.width / (bounds.maxX - bounds.minX);
        const baseScaleY = canvas.height / (bounds.maxY - bounds.minY);
        const baseScale = Math.min(baseScaleX, baseScaleY);

        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX, lastY;

        function toCanvas(x, y) {
            const sx = (x - bounds.minX) * baseScale * zoom + panX;
            const sy = (y - bounds.minY) * baseScale * zoom + panY;
            return [sx, sy];
        }

        function draw() {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            rooms.forEach((room, i) => {
                ctx.beginPath();
                const [sx, sy] = toCanvas(room.points[0][0], room.points[0][1]);
                ctx.moveTo(sx, sy);
                room.points.slice(1).forEach(p => {
                    const [px, py] = toCanvas(p[0], p[1]);
                    ctx.lineTo(px, py);
                });
                ctx.closePath();
                ctx.fillStyle = `hsl(${i * 25}, 50%, 30%)`;
                ctx.fill();
                ctx.strokeStyle = '#0f3460';
                ctx.stroke();

                const cx = room.points.reduce((s, p) => s + p[0], 0) / room.points.length;
                const cy = room.points.reduce((s, p) => s + p[1], 0) / room.points.length;
                const [tx, ty] = toCanvas(cx, cy);
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, tx, ty);
            });
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const oldZoom = zoom;
            zoom *= e.deltaY < 0 ? 1.1 : 0.9;
            zoom = Math.max(0.5, Math.min(10, zoom));

            panX = mx - (mx - panX) * (zoom / oldZoom);
            panY = my - (my - panY) * (zoom / oldZoom);
            drawAll();
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            panX += e.clientX - lastX;
            panY += e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
            drawAll();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        const cats = {};

        function drawCats() {
            Object.values(cats).forEach(cat => {
                const [cx, cy] = toCanvas(cat.x, cat.y);
                ctx.beginPath();
                ctx.arc(cx, cy, 8 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = cat.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(cat.name, cx, cy - 14 * zoom);
            });
        }

        function drawAll() {
            draw();
            drawCats();
        }

        const catColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
        let colorIndex = 0;

        const ws = new WebSocket(`ws://${location.host}/ws/positions`);
        ws.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (!cats[data.device_id]) {
                cats[data.device_id] = { color: catColors[colorIndex++ % catColors.length] };
            }
            cats[data.device_id].name = data.device_name;
            cats[data.device_id].x = data.x;
            cats[data.device_id].y = data.y;
            drawAll();
        };

        canvas.style.cursor = 'grab';
        drawAll();
    </script>
</body>
</html>
