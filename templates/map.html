<!DOCTYPE html>
<html>
<head>
    <title>Cat GPS - Map</title>
    <style>
        :root {
            color-scheme: light dark;

            /* Page + map surfaces */
            --page-bg: #f5f5f7;
            --map-bg: #ffffff;

            /* Rooms */
            --room-stroke: #cbd5e1;
            --room-fill-lightness: 72%;
            --room-label-color: #111827;
            --room-label-stroke: transparent;

            /* Cats */
            --cat-label-color: #111827;
            --cat-label-stroke: transparent;
            --cat-icon-stroke: #ffffff;

            /* Misc */
            --node-color: #9ca3af;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --page-bg: #020617;
                --map-bg: #0b1120;
                --room-stroke: #1f2937;
                --room-fill-lightness: 25%;

                --room-label-color: #e5e7eb;
                --room-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-label-color: #f9fafb;
                --cat-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-icon-stroke: #0b1120;
                --node-color: #9ca3af;
            }
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: var(--page-bg);
        }

        #map {
            width: 100vw;
            height: 100vh;
            background: var(--map-bg);
            cursor: grab;
        }

        #map:active {
            cursor: grabbing;
        }

        .room polygon {
            stroke: var(--room-stroke);
            stroke-width: 1;
        }

        .room__label {
            font-size: 10px;
            font-family: sans-serif;
            fill: var(--room-label-color);
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--room-label-stroke);
            stroke-width: 2px;
        }

        .cat {
            transition: transform 0.3s ease-out;
        }

        .cat__icon {
            stroke: var(--cat-icon-stroke);
            stroke-width: 2;
        }

        .cat__label {
            font-size: 12px;
            font-weight: bold;
            font-family: sans-serif;
            fill: var(--cat-label-color);
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--cat-label-stroke);
            stroke-width: 2px;
        }

        .node {
            fill: var(--node-color);
        }

        .mode-selector {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 100;
            display: flex;
            gap: 4px;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 4px;
        }

        .mode-selector button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-family: sans-serif;
            background: transparent;
            color: var(--room-label-color);
            transition: background 0.2s;
        }

        .mode-selector button:hover {
            background: var(--room-stroke);
        }

        .mode-selector button.active {
            background: #4ecdc4;
            color: #111827;
        }

        .cat-filter {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 100;
            display: none;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .cat-filter.visible {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cat-filter label {
            font-size: 14px;
            font-family: sans-serif;
            color: var(--room-label-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .cat-filter input[type="radio"] {
            cursor: pointer;
        }

        .time-range-selector {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .time-range-selector.visible {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .time-range-selector label {
            font-size: 14px;
            font-family: sans-serif;
            color: var(--room-label-color);
        }

        .time-range-selector select,
        .time-range-selector input[type="datetime-local"] {
            padding: 6px 10px;
            border: 1px solid var(--room-stroke);
            border-radius: 6px;
            background: var(--map-bg);
            color: var(--room-label-color);
            font-size: 14px;
            font-family: sans-serif;
            cursor: pointer;
        }

        .time-range-selector span {
            color: var(--room-label-color);
            font-family: sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="mode-selector">
        <button id="mode-realtime" class="active">Real-time</button>
        <button id="mode-heatmap">Heatmap</button>
    </div>
    <div class="time-range-selector" id="time-range-selector">
        <label for="time-range">Time range:</label>
        <select id="time-range">
            <option value="1">1 hour</option>
            <option value="6">6 hours</option>
            <option value="12">12 hours</option>
            <option value="24" selected>24 hours</option>
            <option value="48">48 hours</option>
            <option value="168">7 days</option>
            <option value="custom">Custom...</option>
        </select>
        <div id="custom-range" style="display: none; margin-left: 8px; gap: 8px; align-items: center;">
            <input type="datetime-local" id="start-time">
            <span>to</span>
            <input type="datetime-local" id="end-time">
        </div>
    </div>
    <div class="cat-filter" id="cat-filter">
        <label>
            <input type="radio" name="cat-select" value="" checked>
            Both
        </label>
    </div>
    <svg id="map" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
        <g id="viewport">
            <g id="rooms">
                {% for room in rooms %}
                <g class="room" data-room-id="{{ room.name }}">
                    <polygon points="{% for point in room.svg_points %}{{ point[0] }},{{ point[1] }}{% if not loop.last %} {% endif %}{% endfor %}" style="fill: hsl({{ loop.index0 * 25 }}, 55%, var(--room-fill-lightness));" />
                </g>
                {% endfor %}
            </g>
            <g id="room-labels">
                {% for room in rooms %}
                <text class="room__label" x="{{ room.label_x }}" y="{{ room.label_y }}">{{ room.name }}</text>
                {% endfor %}
            </g>
            <g id="nodes">
                {% for node in nodes %}
                <circle class="node" cx="{{ node.x }}" cy="{{ node.y }}" r="3" />
                {% endfor %}
            </g>
            <g id="cats"></g>
            <g id="heatmap"></g>
        </g>
    </svg>
    <script>
        const bounds = { minX: {{ min_x }}, minY: {{ min_y }}, maxX: {{ max_x }}, maxY: {{ max_y }} };
        const svg = document.getElementById('map');
        const viewport = document.getElementById('viewport');
        const catsLayer = document.getElementById('cats');

        const svgWidth = 800;
        const svgHeight = 600;
        const baseScaleX = svgWidth / (bounds.maxX - bounds.minX);
        const baseScaleY = svgHeight / (bounds.maxY - bounds.minY);
        const baseScale = Math.min(baseScaleX, baseScaleY);

        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX, lastY;

        function toSvg(x, y) {
            const sx = (x - bounds.minX) * baseScale;
            const sy = svgHeight - (y - bounds.minY) * baseScale;
            return [sx, sy];
        }

        function updateViewport() {
            viewport.setAttribute('transform', `translate(${panX}, ${panY}) scale(${zoom})`);
        }

        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (svgWidth / rect.width);
            const my = (e.clientY - rect.top) * (svgHeight / rect.height);

            const oldZoom = zoom;
            zoom *= e.deltaY < 0 ? 1.1 : 0.9;
            zoom = Math.max(0.5, Math.min(10, zoom));

            panX = mx - (mx - panX) * (zoom / oldZoom);
            panY = my - (my - panY) * (zoom / oldZoom);
            updateViewport();
        });

        svg.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        svg.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = svg.getBoundingClientRect();
            const scaleFactorX = svgWidth / rect.width;
            const scaleFactorY = svgHeight / rect.height;
            panX += (e.clientX - lastX) * scaleFactorX;
            panY += (e.clientY - lastY) * scaleFactorY;
            lastX = e.clientX;
            lastY = e.clientY;
            updateViewport();
        });

        svg.addEventListener('mouseup', () => { isDragging = false; });
        svg.addEventListener('mouseleave', () => { isDragging = false; });

        const cats = {};
        const catColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
        let colorIndex = 0;

        let currentMode = 'realtime';
        const heatmapLayer = document.getElementById('heatmap');
        const modeRealtimeBtn = document.getElementById('mode-realtime');
        const modeHeatmapBtn = document.getElementById('mode-heatmap');
        const catFilterDiv = document.getElementById('cat-filter');
        const timeRangeSelectorDiv = document.getElementById('time-range-selector');
        const timeRangeSelect = document.getElementById('time-range');
        const customRangeDiv = document.getElementById('custom-range');
        const startTimeInput = document.getElementById('start-time');
        const endTimeInput = document.getElementById('end-time');
        let ws = null;
        let devices = [];

        function getSelectedDevice() {
            const checked = document.querySelector('input[name="cat-select"]:checked');
            return checked ? checked.value : '';
        }

        function getSelectedHours() {
            return parseInt(timeRangeSelect.value, 10) || 24;
        }

        function getTimeRangeParams() {
            if (timeRangeSelect.value === 'custom') {
                const start = startTimeInput.value;
                const end = endTimeInput.value;
                if (start && end) {
                    return { start_time: new Date(start).toISOString(), end_time: new Date(end).toISOString() };
                }
                return { hours: 24 };
            }
            return { hours: getSelectedHours() };
        }

        function createCatElement(id, name, color) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('cat');
            g.id = `cat-${id}`;
            g.innerHTML = `
                <circle class="cat__icon" r="8" fill="${color}" />
                <text class="cat__label" y="-14">${name}</text>
            `;
            catsLayer.appendChild(g);
            return g;
        }

        function updateCatPosition(id, x, y) {
            const cat = cats[id];
            if (!cat || !cat.element) return;
            const [sx, sy] = toSvg(x, y);
            cat.element.setAttribute('transform', `translate(${sx}, ${sy})`);
        }

        function connectWebSocket() {
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${wsProtocol}//${location.host}/ws/positions`);
            ws.onmessage = (e) => {
                if (currentMode !== 'realtime') return;
                const data = JSON.parse(e.data);
                if (!cats[data.device_id]) {
                    const color = catColors[colorIndex++ % catColors.length];
                    const element = createCatElement(data.device_id, data.device_name, color);
                    cats[data.device_id] = { element, color };
                }
                const label = cats[data.device_id].element.querySelector('.cat__label');
                if (label) label.textContent = data.device_name;
                updateCatPosition(data.device_id, data.x, data.y);
            };
        }

        function clearHeatmap() {
            heatmapLayer.innerHTML = '';
        }

        function clearCats() {
            catsLayer.innerHTML = '';
            Object.keys(cats).forEach(k => delete cats[k]);
            colorIndex = 0;
        }

        function getDeviceColor(deviceId) {
            const idx = devices.findIndex(d => d.id === deviceId);
            return catColors[idx >= 0 ? idx % catColors.length : 0];
        }

        async function renderHeatmap() {
            clearHeatmap();
            const cellSize = 0.5;
            const selectedDevice = getSelectedDevice();
            const timeParams = getTimeRangeParams();

            if (selectedDevice) {
                const color = getDeviceColor(selectedDevice);
                await renderHeatmapForDevice(cellSize, selectedDevice, color, timeParams);
            } else {
                await renderHeatmapForDevice(cellSize, null, '#ff6b6b', timeParams);
            }
        }

        async function renderHeatmapForDevice(cellSize, deviceId, color, timeParams) {
            let url = `/api/heatmap?cell_size=${cellSize}`;
            if (timeParams.hours) {
                url += `&hours=${timeParams.hours}`;
            }
            if (timeParams.start_time && timeParams.end_time) {
                url += `&start_time=${encodeURIComponent(timeParams.start_time)}&end_time=${encodeURIComponent(timeParams.end_time)}`;
            }
            if (deviceId) {
                url += `&device_id=${encodeURIComponent(deviceId)}`;
            }
            const res = await fetch(url);
            const data = await res.json();

            if (data.bins.length === 0) return;

            const maxCount = Math.max(...data.bins.map(b => b.count));

            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 107, b: 107 };
            };

            const rgb = hexToRgb(color);

            data.bins.forEach(bin => {
                const worldX = bin.grid_x * cellSize;
                const worldY = bin.grid_y * cellSize;
                const [sx, sy] = toSvg(worldX, worldY);
                const [sx2, sy2] = toSvg(worldX + cellSize, worldY + cellSize);
                const width = Math.abs(sx2 - sx);
                const height = Math.abs(sy2 - sy);

                const intensity = bin.count / maxCount;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', sx);
                rect.setAttribute('y', sy2);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('fill', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${0.1 + intensity * 0.7})`);
                rect.setAttribute('rx', '2');
                heatmapLayer.appendChild(rect);
            });
        }

        function setMode(mode, updateUrl = true) {
            currentMode = mode;
            modeRealtimeBtn.classList.toggle('active', mode === 'realtime');
            modeHeatmapBtn.classList.toggle('active', mode === 'heatmap');
            catFilterDiv.classList.toggle('visible', mode === 'heatmap');
            timeRangeSelectorDiv.classList.toggle('visible', mode === 'heatmap');

            if (updateUrl) {
                const url = new URL(location.href);
                url.searchParams.set('view', mode);
                history.replaceState(null, '', url);
            }

            if (mode === 'realtime') {
                clearHeatmap();
                catsLayer.style.display = '';
                if (!ws || ws.readyState === WebSocket.CLOSED) {
                    connectWebSocket();
                }
            } else {
                clearCats();
                catsLayer.style.display = 'none';
                renderHeatmap();
            }
        }

        function getModeFromUrl() {
            const params = new URLSearchParams(location.search);
            const view = params.get('view');
            return view === 'heatmap' ? 'heatmap' : 'realtime';
        }

        async function loadDevices() {
            const res = await fetch('/api/devices');
            devices = await res.json();
            devices.forEach(d => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="radio" name="cat-select" value="${d.id}"> ${d.name}`;
                catFilterDiv.appendChild(label);
            });

            catFilterDiv.addEventListener('change', () => {
                if (currentMode === 'heatmap') {
                    renderHeatmap();
                }
            });
        }

        function updateTimeRangeUrl() {
            const url = new URL(location.href);
            if (timeRangeSelect.value === 'custom') {
                url.searchParams.set('range', 'custom');
                if (startTimeInput.value) url.searchParams.set('start', startTimeInput.value);
                if (endTimeInput.value) url.searchParams.set('end', endTimeInput.value);
                url.searchParams.delete('hours');
            } else {
                url.searchParams.set('hours', timeRangeSelect.value);
                url.searchParams.delete('range');
                url.searchParams.delete('start');
                url.searchParams.delete('end');
            }
            history.replaceState(null, '', url);
        }

        timeRangeSelect.addEventListener('change', () => {
            const isCustom = timeRangeSelect.value === 'custom';
            customRangeDiv.style.display = isCustom ? 'flex' : 'none';
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && !isCustom) {
                renderHeatmap();
            }
        });

        function initCustomTimeDefaults() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            const toLocalISO = (d) => new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            endTimeInput.value = toLocalISO(now);
            startTimeInput.value = toLocalISO(yesterday);
        }

        function loadTimeRangeFromUrl() {
            const params = new URLSearchParams(location.search);
            const range = params.get('range');
            const hours = params.get('hours');
            const start = params.get('start');
            const end = params.get('end');

            if (range === 'custom' && start && end) {
                timeRangeSelect.value = 'custom';
                startTimeInput.value = start;
                endTimeInput.value = end;
                customRangeDiv.style.display = 'flex';
            } else if (hours && [...timeRangeSelect.options].some(o => o.value === hours)) {
                timeRangeSelect.value = hours;
                initCustomTimeDefaults();
            } else {
                initCustomTimeDefaults();
            }
        }
        loadTimeRangeFromUrl();

        startTimeInput.addEventListener('change', () => {
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && startTimeInput.value && endTimeInput.value) {
                renderHeatmap();
            }
        });

        endTimeInput.addEventListener('change', () => {
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && startTimeInput.value && endTimeInput.value) {
                renderHeatmap();
            }
        });

        modeRealtimeBtn.addEventListener('click', () => setMode('realtime'));
        modeHeatmapBtn.addEventListener('click', () => setMode('heatmap'));

        loadDevices();
        const initialMode = getModeFromUrl();
        if (initialMode === 'heatmap') {
            setMode('heatmap', false);
        } else {
            connectWebSocket();
        }
    </script>
</body>
</html>
