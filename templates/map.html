<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Cat GPS - Map</title>
    <style>
        :root {
            color-scheme: light dark;

            /* Page + map surfaces */
            --page-bg: #f5f5f7;
            --map-bg: #ffffff;

            /* Rooms */
            --room-stroke: #cbd5e1;
            --room-fill-lightness: 72%;
            --room-label-color: #111827;
            --room-label-stroke: transparent;

            /* Cats */
            --cat-label-color: #111827;
            --cat-label-stroke: transparent;
            --cat-icon-stroke: #ffffff;

            /* Misc */
            --node-color: #9ca3af;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --page-bg: #020617;
                --map-bg: #0b1120;
                --room-stroke: #1f2937;
                --room-fill-lightness: 25%;

                --room-label-color: #e5e7eb;
                --room-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-label-color: #f9fafb;
                --cat-label-stroke: rgba(0, 0, 0, 0.85);

                --cat-icon-stroke: #0b1120;
                --node-color: #9ca3af;
            }
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: var(--page-bg);
        }

        #map {
            width: 100vw;
            height: 100vh;
            background: var(--map-bg);
            cursor: grab;
        }

        #map:active {
            cursor: grabbing;
        }

        .room polygon {
            stroke: var(--room-stroke);
            stroke-width: 1;
        }

        .room__label {
            font-size: 10px;
            font-family: sans-serif;
            fill: var(--room-label-color);
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--room-label-stroke);
            stroke-width: 2px;
        }

        .cat {
            transition: transform 0.3s ease-out;
        }

        .cat__icon {
            stroke: var(--cat-icon-stroke);
            stroke-width: 2;
        }

        .cat__label {
            font-size: 12px;
            font-weight: bold;
            font-family: sans-serif;
            fill: var(--cat-label-color);
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke fill;
            stroke: var(--cat-label-stroke);
            stroke-width: 2px;
        }

        .node {
            fill: var(--node-color);
        }

        .mode-selector {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 100;
            display: flex;
            gap: 4px;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 4px;
        }

        .mode-selector button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-family: sans-serif;
            background: transparent;
            color: var(--room-label-color);
            transition: background 0.2s;
        }

        .mode-selector button:hover {
            background: var(--room-stroke);
        }

        .mode-selector button.active {
            background: #4ecdc4;
            color: #111827;
        }

        .cat-filter {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 100;
            display: none;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .cat-filter.visible {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cat-filter label {
            font-size: 14px;
            font-family: sans-serif;
            color: var(--room-label-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .cat-filter input[type="radio"] {
            cursor: pointer;
        }

        .time-range-selector {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
            background: var(--map-bg);
            border: 1px solid var(--room-stroke);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .time-range-selector.visible {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .time-range-selector label {
            font-size: 14px;
            font-family: sans-serif;
            color: var(--room-label-color);
        }

        .time-range-selector select,
        .time-range-selector input[type="datetime-local"] {
            padding: 6px 10px;
            border: 1px solid var(--room-stroke);
            border-radius: 6px;
            background: var(--map-bg);
            color: var(--room-label-color);
            font-size: 14px;
            font-family: sans-serif;
            cursor: pointer;
        }

        .time-range-selector span {
            color: var(--room-label-color);
            font-family: sans-serif;
            font-size: 14px;
        }

        .time-adjust-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .time-adjust-row {
            display: flex;
            gap: 2px;
        }

        .time-adjust-btn {
            width: 24px;
            height: 20px;
            padding: 0;
            border: 1px solid var(--room-stroke);
            border-radius: 4px;
            background: var(--map-bg);
            color: var(--room-label-color);
            font-size: 10px;
            font-family: sans-serif;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-adjust-btn:hover {
            background: var(--room-stroke);
        }

        .time-adjust-labels {
            display: flex;
            gap: 2px;
            font-size: 8px;
            color: var(--room-label-color);
            font-family: sans-serif;
        }

        .time-adjust-labels span {
            width: 24px;
            text-align: center;
            font-size: 8px;
        }

        .both-adjust {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
            padding-left: 8px;
            border-left: 1px solid var(--room-stroke);
        }

        .both-adjust-label {
            font-size: 10px;
            color: var(--room-label-color);
            font-family: sans-serif;
        }

        .time-presets {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            padding-left: 8px;
            border-left: 1px solid var(--room-stroke);
        }

        .time-presets-label {
            font-size: 10px;
            color: var(--room-label-color);
            font-family: sans-serif;
        }

        .time-preset-btn {
            padding: 4px 8px;
            border: 1px solid var(--room-stroke);
            border-radius: 4px;
            background: var(--map-bg);
            color: var(--room-label-color);
            font-size: 11px;
            font-family: sans-serif;
            cursor: pointer;
        }

        .time-preset-btn:hover {
            background: var(--room-stroke);
        }

        .cat-legend {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--room-stroke);
        }

        .cat-legend__item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            font-family: sans-serif;
            color: var(--room-label-color);
        }

        .cat-legend__swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* Mobile responsive styles */
        @media (max-width: 600px) {
            .mode-selector {
                top: 8px;
                left: 8px;
                padding: 2px;
            }

            .mode-selector button {
                padding: 6px 12px;
                font-size: 12px;
            }

            .time-range-selector {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                transform: none;
                border-radius: 16px 16px 0 0;
                padding: 12px;
                flex-direction: column;
                gap: 12px;
                max-height: 50vh;
                overflow-y: auto;
            }

            .time-range-selector select {
                width: 100%;
            }

            #custom-range {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 12px !important;
            }

            #custom-range > span {
                text-align: center;
            }

            .time-adjust-group {
                width: 100%;
            }

            .time-adjust-group input[type="datetime-local"] {
                width: 100%;
                box-sizing: border-box;
            }

            /* Hide +/- adjustment buttons on mobile - use native picker */
            .time-adjust-row,
            .time-adjust-labels {
                display: none !important;
            }

            .both-adjust {
                display: none !important;
            }

            .time-presets {
                margin-left: 0;
                padding-left: 0;
                border-left: none;
                padding-top: 8px;
                border-top: 1px solid var(--room-stroke);
                width: 100%;
            }

            .time-presets .time-adjust-row {
                display: flex !important;
                justify-content: center;
                gap: 8px;
            }

            .time-preset-btn {
                flex: 1;
                padding: 8px 12px;
                font-size: 14px;
            }

            .cat-filter {
                position: fixed;
                top: 8px;
                right: 8px;
                left: auto;
                flex-direction: column;
                padding: 6px 10px;
                gap: 6px;
            }

            .cat-filter label {
                font-size: 12px;
            }

            .cat-legend {
                margin-left: 0;
                padding-left: 0;
                border-left: none;
                margin-top: 6px;
                padding-top: 6px;
                border-top: 1px solid var(--room-stroke);
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
            }

            .cat-legend__item {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="mode-selector">
        <button id="mode-realtime" class="active">Real-time</button>
        <button id="mode-heatmap">Heatmap</button>
    </div>
    <div class="time-range-selector" id="time-range-selector">
        <label for="time-range">Time range:</label>
        <select id="time-range">
            <option value="1">1 hour</option>
            <option value="6">6 hours</option>
            <option value="12">12 hours</option>
            <option value="24" selected>24 hours</option>
            <option value="48">48 hours</option>
            <option value="168">7 days</option>
            <option value="custom">Custom...</option>
        </select>
        <div id="custom-range" style="display: none; margin-left: 8px; gap: 8px; align-items: center;">
            <div class="time-adjust-group">
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="start" data-unit="day" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="start" data-unit="hour" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="start" data-unit="minute" data-delta="1">+</button>
                </div>
                <input type="datetime-local" id="start-time">
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="start" data-unit="day" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="start" data-unit="hour" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="start" data-unit="minute" data-delta="-1">−</button>
                </div>
                <div class="time-adjust-labels"><span>D</span><span>H</span><span>M</span></div>
            </div>
            <span>to</span>
            <div class="time-adjust-group">
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="end" data-unit="day" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="end" data-unit="hour" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="end" data-unit="minute" data-delta="1">+</button>
                </div>
                <input type="datetime-local" id="end-time">
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="end" data-unit="day" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="end" data-unit="hour" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="end" data-unit="minute" data-delta="-1">−</button>
                </div>
                <div class="time-adjust-labels"><span>D</span><span>H</span><span>M</span></div>
            </div>
            <div class="both-adjust">
                <span class="both-adjust-label">Both</span>
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="both" data-unit="day" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="both" data-unit="hour" data-delta="1">+</button>
                    <button class="time-adjust-btn" data-target="both" data-unit="minute" data-delta="1">+</button>
                </div>
                <div class="time-adjust-row">
                    <button class="time-adjust-btn" data-target="both" data-unit="day" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="both" data-unit="hour" data-delta="-1">−</button>
                    <button class="time-adjust-btn" data-target="both" data-unit="minute" data-delta="-1">−</button>
                </div>
                <div class="time-adjust-labels"><span>D</span><span>H</span><span>M</span></div>
            </div>
            <div class="time-presets">
                <span class="time-presets-label">Presets</span>
                <div class="time-adjust-row">
                    <button class="time-preset-btn" data-hours="1">1h</button>
                    <button class="time-preset-btn" data-hours="6">6h</button>
                    <button class="time-preset-btn" data-hours="12">12h</button>
                </div>
                <div class="time-adjust-row">
                    <button class="time-preset-btn" data-hours="24">1d</button>
                    <button class="time-preset-btn" data-hours="48">2d</button>
                    <button class="time-preset-btn" data-hours="168">7d</button>
                </div>
            </div>
        </div>
    </div>
    <div class="cat-filter" id="cat-filter">
        <label>
            <input type="radio" name="cat-select" value="" checked>
            Both
        </label>
    </div>
    <svg id="map" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
        <g id="viewport">
            <g id="rooms">
                {% for room in rooms %}
                <g class="room" data-room-id="{{ room.name }}">
                    <polygon points="{% for point in room.svg_points %}{{ point[0] }},{{ point[1] }}{% if not loop.last %} {% endif %}{% endfor %}" style="fill: hsl({{ loop.index0 * 25 }}, 55%, var(--room-fill-lightness));" />
                </g>
                {% endfor %}
            </g>
            <g id="room-labels">
                {% for room in rooms %}
                <text class="room__label" x="{{ room.label_x }}" y="{{ room.label_y }}">{{ room.name }}</text>
                {% endfor %}
            </g>
            <g id="nodes">
                {% for node in nodes %}
                <circle class="node" cx="{{ node.x }}" cy="{{ node.y }}" r="3" />
                {% endfor %}
            </g>
            <g id="cats"></g>
            <g id="heatmap"></g>
        </g>
    </svg>
    <script>
        const bounds = { minX: {{ min_x }}, minY: {{ min_y }}, maxX: {{ max_x }}, maxY: {{ max_y }} };
        const svg = document.getElementById('map');
        const viewport = document.getElementById('viewport');
        const catsLayer = document.getElementById('cats');

        const svgWidth = 800;
        const svgHeight = 600;
        const baseScaleX = svgWidth / (bounds.maxX - bounds.minX);
        const baseScaleY = svgHeight / (bounds.maxY - bounds.minY);
        const baseScale = Math.min(baseScaleX, baseScaleY);

        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX, lastY;

        function toSvg(x, y) {
            const sx = (x - bounds.minX) * baseScale;
            const sy = svgHeight - (y - bounds.minY) * baseScale;
            return [sx, sy];
        }

        function updateViewport() {
            viewport.setAttribute('transform', `translate(${panX}, ${panY}) scale(${zoom})`);
        }

        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (svgWidth / rect.width);
            const my = (e.clientY - rect.top) * (svgHeight / rect.height);

            const oldZoom = zoom;
            zoom *= e.deltaY < 0 ? 1.1 : 0.9;
            zoom = Math.max(0.5, Math.min(10, zoom));

            panX = mx - (mx - panX) * (zoom / oldZoom);
            panY = my - (my - panY) * (zoom / oldZoom);
            updateViewport();
        });

        svg.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        svg.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = svg.getBoundingClientRect();
            const scaleFactorX = svgWidth / rect.width;
            const scaleFactorY = svgHeight / rect.height;
            panX += (e.clientX - lastX) * scaleFactorX;
            panY += (e.clientY - lastY) * scaleFactorY;
            lastX = e.clientX;
            lastY = e.clientY;
            updateViewport();
        });

        svg.addEventListener('mouseup', () => { isDragging = false; });
        svg.addEventListener('mouseleave', () => { isDragging = false; });

        const cats = {};
        const catColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
        let colorIndex = 0;

        let currentMode = 'realtime';
        const heatmapLayer = document.getElementById('heatmap');
        const modeRealtimeBtn = document.getElementById('mode-realtime');
        const modeHeatmapBtn = document.getElementById('mode-heatmap');
        const catFilterDiv = document.getElementById('cat-filter');
        const timeRangeSelectorDiv = document.getElementById('time-range-selector');
        const timeRangeSelect = document.getElementById('time-range');
        const customRangeDiv = document.getElementById('custom-range');
        const startTimeInput = document.getElementById('start-time');
        const endTimeInput = document.getElementById('end-time');
        let ws = null;
        let devices = [];
        let reconnectAttempts = 0;
        let reconnectTimeout = null;
        const MAX_RECONNECT_DELAY = 30000;
        let heatmapAbortController = null;

        function getSelectedDevice() {
            const checked = document.querySelector('input[name="cat-select"]:checked');
            return checked ? checked.value : '';
        }

        function getSelectedHours() {
            return parseInt(timeRangeSelect.value, 10) || 24;
        }

        function getTimeRangeParams() {
            if (timeRangeSelect.value === 'custom') {
                const start = startTimeInput.value;
                const end = endTimeInput.value;
                if (start && end) {
                    return { start_time: new Date(start).toISOString(), end_time: new Date(end).toISOString() };
                }
                return { hours: 24 };
            }
            return { hours: getSelectedHours() };
        }

        function createCatElement(id, name, color) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('cat');
            g.id = `cat-${id}`;
            g.innerHTML = `
                <circle class="cat__icon" r="8" fill="${color}" />
                <text class="cat__label" y="-14">${name}</text>
            `;
            catsLayer.appendChild(g);
            return g;
        }

        function updateCatPosition(id, x, y) {
            const cat = cats[id];
            if (!cat || !cat.element) return;
            const [sx, sy] = toSvg(x, y);
            cat.element.setAttribute('transform', `translate(${sx}, ${sy})`);
        }

        function scheduleReconnect() {
            if (reconnectTimeout) return;
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), MAX_RECONNECT_DELAY);
            reconnectAttempts++;
            console.log(`WebSocket reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);
            reconnectTimeout = setTimeout(() => {
                reconnectTimeout = null;
                if (currentMode === 'realtime') {
                    connectWebSocket();
                }
            }, delay);
        }

        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                return;
            }
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${wsProtocol}//${location.host}/ws/positions`);

            ws.onopen = () => {
                console.log('WebSocket connected');
                reconnectAttempts = 0;
            };

            ws.onmessage = (e) => {
                if (currentMode !== 'realtime') return;
                const data = JSON.parse(e.data);
                if (!cats[data.device_id]) {
                    const color = catColors[colorIndex++ % catColors.length];
                    const element = createCatElement(data.device_id, data.device_name, color);
                    cats[data.device_id] = { element, color };
                }
                const label = cats[data.device_id].element.querySelector('.cat__label');
                if (label) label.textContent = data.device_name;
                updateCatPosition(data.device_id, data.x, data.y);
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                if (currentMode === 'realtime') {
                    scheduleReconnect();
                }
            };

            ws.onerror = (err) => {
                console.error('WebSocket error', err);
                ws.close();
            };
        }

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && currentMode === 'realtime') {
                if (!ws || ws.readyState === WebSocket.CLOSED) {
                    reconnectAttempts = 0;
                    connectWebSocket();
                }
            }
        });

        window.addEventListener('online', () => {
            if (currentMode === 'realtime' && (!ws || ws.readyState === WebSocket.CLOSED)) {
                reconnectAttempts = 0;
                connectWebSocket();
            }
        });

        function clearHeatmap() {
            heatmapLayer.innerHTML = '';
        }

        function clearCats() {
            catsLayer.innerHTML = '';
            Object.keys(cats).forEach(k => delete cats[k]);
            colorIndex = 0;
        }

        function getDeviceColor(deviceId) {
            const idx = devices.findIndex(d => d.id === deviceId);
            return catColors[idx >= 0 ? idx % catColors.length : 0];
        }

        async function renderHeatmap() {
            if (heatmapAbortController) {
                heatmapAbortController.abort();
            }
            heatmapAbortController = new AbortController();
            const signal = heatmapAbortController.signal;

            clearHeatmap();
            const cellSize = 0.5;
            const selectedDevice = getSelectedDevice();
            const timeParams = getTimeRangeParams();

            try {
                if (selectedDevice) {
                    const color = getDeviceColor(selectedDevice);
                    await renderHeatmapForDevice(cellSize, selectedDevice, color, timeParams, signal);
                } else {
                    for (const d of devices) {
                        const color = getDeviceColor(d.id);
                        await renderHeatmapForDevice(cellSize, d.id, color, timeParams, signal);
                    }
                }
            } catch (e) {
                if (e.name !== 'AbortError') throw e;
            }
        }

        async function renderHeatmapForDevice(cellSize, deviceId, color, timeParams, signal) {
            let url = `/api/heatmap?cell_size=${cellSize}`;
            if (timeParams.hours) {
                url += `&hours=${timeParams.hours}`;
            }
            if (timeParams.start_time && timeParams.end_time) {
                url += `&start_time=${encodeURIComponent(timeParams.start_time)}&end_time=${encodeURIComponent(timeParams.end_time)}`;
            }
            if (deviceId) {
                url += `&device_id=${encodeURIComponent(deviceId)}`;
            }
            const res = await fetch(url, { signal });
            const data = await res.json();

            if (data.bins.length === 0) return;

            const maxCount = Math.max(...data.bins.map(b => b.count));

            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 107, b: 107 };
            };

            const rgb = hexToRgb(color);

            data.bins.forEach(bin => {
                const worldX = bin.grid_x * cellSize;
                const worldY = bin.grid_y * cellSize;
                const [sx, sy] = toSvg(worldX, worldY);
                const [sx2, sy2] = toSvg(worldX + cellSize, worldY + cellSize);
                const width = Math.abs(sx2 - sx);
                const height = Math.abs(sy2 - sy);

                const intensity = bin.count / maxCount;
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', sx);
                rect.setAttribute('y', sy2);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('fill', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${0.1 + intensity * 0.7})`);
                rect.setAttribute('rx', '2');
                heatmapLayer.appendChild(rect);
            });
        }

        function setMode(mode, updateUrl = true) {
            currentMode = mode;
            modeRealtimeBtn.classList.toggle('active', mode === 'realtime');
            modeHeatmapBtn.classList.toggle('active', mode === 'heatmap');
            catFilterDiv.classList.toggle('visible', mode === 'heatmap');
            timeRangeSelectorDiv.classList.toggle('visible', mode === 'heatmap');

            if (updateUrl) {
                const url = new URL(location.href);
                url.searchParams.set('view', mode);
                history.replaceState(null, '', url);
            }

            if (mode === 'realtime') {
                clearHeatmap();
                catsLayer.style.display = '';
                if (!ws || ws.readyState === WebSocket.CLOSED) {
                    connectWebSocket();
                }
            } else {
                clearCats();
                catsLayer.style.display = 'none';
                renderHeatmap();
            }
        }

        function getModeFromUrl() {
            const params = new URLSearchParams(location.search);
            const view = params.get('view');
            return view === 'heatmap' ? 'heatmap' : 'realtime';
        }

        async function loadDevices() {
            const res = await fetch('/api/devices');
            devices = await res.json();
            devices.forEach(d => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="radio" name="cat-select" value="${d.id}"> ${d.name}`;
                catFilterDiv.appendChild(label);
            });

            const legend = document.createElement('div');
            legend.className = 'cat-legend';
            devices.forEach(d => {
                const color = getDeviceColor(d.id);
                const item = document.createElement('div');
                item.className = 'cat-legend__item';
                const swatch = document.createElement('span');
                swatch.className = 'cat-legend__swatch';
                swatch.style.backgroundColor = color;
                item.appendChild(swatch);
                item.appendChild(document.createTextNode(d.name));
                legend.appendChild(item);
            });
            catFilterDiv.appendChild(legend);

            catFilterDiv.addEventListener('change', () => {
                if (currentMode === 'heatmap') {
                    renderHeatmap();
                }
            });
        }

        function updateTimeRangeUrl() {
            const url = new URL(location.href);
            if (timeRangeSelect.value === 'custom') {
                url.searchParams.set('range', 'custom');
                if (startTimeInput.value) url.searchParams.set('start', startTimeInput.value);
                if (endTimeInput.value) url.searchParams.set('end', endTimeInput.value);
                url.searchParams.delete('hours');
            } else {
                url.searchParams.set('hours', timeRangeSelect.value);
                url.searchParams.delete('range');
                url.searchParams.delete('start');
                url.searchParams.delete('end');
            }
            history.replaceState(null, '', url);
        }

        timeRangeSelect.addEventListener('change', () => {
            const isCustom = timeRangeSelect.value === 'custom';
            customRangeDiv.style.display = isCustom ? 'flex' : 'none';
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && !isCustom) {
                renderHeatmap();
            }
        });

        function initCustomTimeDefaults() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            const toLocalISO = (d) => new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            endTimeInput.value = toLocalISO(now);
            startTimeInput.value = toLocalISO(yesterday);
        }

        function loadTimeRangeFromUrl() {
            const params = new URLSearchParams(location.search);
            const range = params.get('range');
            const hours = params.get('hours');
            const start = params.get('start');
            const end = params.get('end');

            if (range === 'custom' && start && end) {
                timeRangeSelect.value = 'custom';
                startTimeInput.value = start;
                endTimeInput.value = end;
                customRangeDiv.style.display = 'flex';
            } else if (hours && [...timeRangeSelect.options].some(o => o.value === hours)) {
                timeRangeSelect.value = hours;
                initCustomTimeDefaults();
            } else {
                initCustomTimeDefaults();
            }
        }
        loadTimeRangeFromUrl();

        startTimeInput.addEventListener('change', () => {
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && startTimeInput.value && endTimeInput.value) {
                renderHeatmap();
            }
        });

        endTimeInput.addEventListener('change', () => {
            updateTimeRangeUrl();
            if (currentMode === 'heatmap' && startTimeInput.value && endTimeInput.value) {
                renderHeatmap();
            }
        });

        function adjustTime(input, unit, delta) {
            if (!input.value) return;
            const date = new Date(input.value);
            if (unit === 'day') date.setDate(date.getDate() + delta);
            else if (unit === 'hour') date.setHours(date.getHours() + delta);
            else if (unit === 'minute') date.setMinutes(date.getMinutes() + delta);
            const toLocalISO = (d) => new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            input.value = toLocalISO(date);
        }

        document.querySelectorAll('.time-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const hours = parseInt(btn.dataset.hours, 10);
                const now = new Date();
                const start = new Date(now.getTime() - hours * 60 * 60 * 1000);
                const toLocalISO = (d) => new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                startTimeInput.value = toLocalISO(start);
                endTimeInput.value = toLocalISO(now);
                updateTimeRangeUrl();
                if (currentMode === 'heatmap') {
                    renderHeatmap();
                }
            });
        });

        document.querySelectorAll('.time-adjust-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const target = btn.dataset.target;
                const unit = btn.dataset.unit;
                const delta = parseInt(btn.dataset.delta, 10);
                if (target === 'start' || target === 'both') {
                    adjustTime(startTimeInput, unit, delta);
                }
                if (target === 'end' || target === 'both') {
                    adjustTime(endTimeInput, unit, delta);
                }
                updateTimeRangeUrl();
                if (currentMode === 'heatmap' && startTimeInput.value && endTimeInput.value) {
                    renderHeatmap();
                }
            });
        });

        modeRealtimeBtn.addEventListener('click', () => setMode('realtime'));
        modeHeatmapBtn.addEventListener('click', () => setMode('heatmap'));

        (async () => {
            await loadDevices();
            const initialMode = getModeFromUrl();
            if (initialMode === 'heatmap') {
                setMode('heatmap', false);
            } else {
                connectWebSocket();
            }
        })();
    </script>
</body>
</html>
